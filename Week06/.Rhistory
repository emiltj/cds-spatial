plot(K_poisson, . ~ r)
# Subtract pi * r ^ 2 from the Y-axis and plot
plot(K_poisson, . - pi * r ^ 2 ~ r)
# The default plot shows quadratic growth
plot(K_poisson, . ~ r)
# Subtract pi * r ^ 2 from the Y-axis and plot
plot(K_poisson, . - pi * r ^ 2 ~ r)
# Compute envelopes of K under random locations
K_cluster_env <- ___(___, ___, correction = "___")
# The default plot shows quadratic growth
plot(K_poisson, . ~ r)
# Subtract pi * r ^ 2 from the Y-axis and plot
plot(K_poisson, . - pi * r ^ 2 ~ r)
# The default plot shows quadratic growth
plot(K_poisson, . ~ r)
# Subtract pi * r ^ 2 from the Y-axis and plot
plot(K_poisson, . - pi * r ^ 2 ~ r)
# Compute envelopes of K under random locations
K_cluster_env <- envelope(p_cluster, Kest, correction = "border")
# Insert the full formula to plot K minus pi * r^2
plot(K_cluster_env, . - pi * r ^ 2 ~ r)
plot(K_regular_env, . - pi * r ^ 2 ~ r)
# Repeat for regular data
K_regular_env <- envelope(p_regular, Kest, correction = "border")
plot(K_regular_env, . - pi * r ^ 2 ~ r)
# Insert the full formula to plot K minus pi * r^2
plot(K_cluster_env, . - pi * r ^ 2 ~ r)
# Insert the full formula to plot K minus pi * r^2
plot(K_cluster_env, . - pi * r ^ 2 ~ r)
# Compute envelopes of K under random locations
K_cluster_env <- envelope(p_cluster, Kest, correction = "border")
# Insert the full formula to plot K minus pi * r^2
plot(K_cluster_env, . - pi * r ^ 2 ~ r)
# Repeat for regular data
K_regular_env <- envelope(p_regular, Kest, correction = "border")
plot(K_regular_env, . - pi * r ^ 2 ~ r)
# Insert the full formula to plot K minus pi * r^2
plot(K_cluster_env, . - pi * r ^ 2 ~ r)
# Repeat for regular data
K_regular_env <- envelope(p_regular, Kest, correction = "border")
plot(K_regular_env, . - pi * r ^ 2 ~ r)
# Repeat for regular data
K_regular_env <- envelope(p_regular, Kest, correction = "border")
plot(K_regular_env, . - pi * r ^ 2 ~ r)
# Compute envelopes of K under random locations
K_cluster_env <- envelope(p_cluster, Kest, correction = "border")
# Insert the full formula to plot K minus pi * r^2
plot(K_cluster_env, . - pi * r ^ 2 ~ r)
# Repeat for regular data
K_regular_env <- envelope(p_regular, Kest, correction = "border")
plot(K_regular_env, . - pi * r ^ 2 ~ r)
# Regular points from a Strauss process
set.seed(12)
p_regular <- rStrauss(beta = 2.9, gamma = 0.025, R = .5, W = disc10)
plot(p_regular)
# Point patterns are pre-defined
p_poisson; p_regular
# Calc nearest-neighbor distances for Poisson point data
nnd_poisson <- nndist(p_poisson)
# Draw a histogram of nearest-neighbor distances
hist(nnd_poisson)
# Plot G(r) vs. r
plot(G_poisson)
# Repeat for regular point data
nnd_regular <- nndist(p_regular)
hist(nnd_regular)
P_regular <- Gest(p_poisson)
plot(P_regular)
# Estimate G(r)
G_poisson <- Gest(p_poisson)
# Point patterns are pre-defined
p_poisson; p_cluster; p_regular
# Estimate the K-function for the Poisson points
K_poisson <- Kest(p_poisson, correction = "border")
# The default plot shows quadratic growth
plot(K_poisson, . ~ r)
# Subtract pi * r ^ 2 from the Y-axis and plot
plot(K_poisson, . - pi * r ^ 2 ~ r) #essentially centers the red line (the line of a ideal poisson distribution), and therefore also shows the deviance from our distribution (just as the previous plot)
# Compute envelopes of K under random locations
K_cluster_env <- envelope(p_cluster, Kest, correction = "border")
# Insert the full formula to plot K minus pi * r^2
plot(K_cluster_env, . - pi * r ^ 2 ~ r)
# Repeat for regular data
K_regular_env <- envelope(p_regular, Kest, correction = "border")
plot(K_regular_env, . - pi * r ^ 2 ~ r)
K_poisson_env <- envelope(p_poisson, Kest, correction = "border")
# Insert the full formula to plot K minus pi * r^2
plot(K_poisson_env, . - pi * r ^ 2 ~ r)
K_poisson_env <- envelope(p_poisson, Kest, correction = "border")
# Insert the full formula to plot K minus pi * r^2
plot(K_poisson_env, . - pi * r ^ 2 ~ r)
# Point patterns are pre-defined
p_poisson; p_cluster; p_regular
# Estimate the K-function for the Poisson points
K_poisson <- Kest(p_poisson, correction = "border")
# The default plot shows quadratic growth
plot(K_poisson, . ~ r)
# Subtract pi * r ^ 2 from the Y-axis and plot
plot(K_poisson, . - pi * r ^ 2 ~ r) #essentially centers the red line (the line of a ideal poisson distribution), and therefore also shows the deviance from our distribution (just as the previous plot)
# Compute envelopes of K under random locations
K_cluster_env <- envelope(p_cluster, Kest, correction = "border")
# Insert the full formula to plot K minus pi * r^2
plot(K_cluster_env, . - pi * r ^ 2 ~ r)
# Insert the full formula to plot K minus pi * r^2
plot(K_cluster_env, . - pi * r ^ 2 ~ r)
# Repeat for regular data
K_regular_env <- envelope(p_regular, Kest, correction = "border")
plot(K_regular_env, . - pi * r ^ 2 ~ r)
# p_cluster and p_regular
# Generate clustered points from a Thomas process
set.seed(123)
p_cluster <- rThomas(kappa = 0.35, scale = 1, mu = 3, win = disc10)
plot(p_cluster)
# Regular points from a Strauss process
set.seed(123)
plot(p_regular)
p_regular <- rStrauss(beta = 2.9, gamma = 0.025, R = .5, W = disc10)
# Point patterns are pre-defined
p_poisson; p_regular
# Calc nearest-neighbor distances for Poisson point data
nnd_poisson <- nndist(p_poisson)
# Draw a histogram of nearest-neighbor distances
hist(nnd_poisson)
# Estimate G(r)
G_poisson <- Gest(p_poisson)
# Plot G(r) vs. r
plot(G_poisson)
hist(nnd_regular)
P_regular <- Gest(p_poisson)
plot(P_regular)
# Repeat for regular point data
nnd_regular <- nndist(p_regular)
# Point patterns are pre-defined
p_poisson; p_cluster; p_regular
# Estimate the K-function for the Poisson points
K_poisson <- Kest(p_poisson, correction = "border")
# The default plot shows quadratic growth
plot(K_poisson, . ~ r)
# Subtract pi * r ^ 2 from the Y-axis and plot
plot(K_poisson, . - pi * r ^ 2 ~ r) #essentially centers the red line (the line of a ideal poisson distribution), and therefore also shows the deviance from our distribution (just as the previous plot)
# Compute envelopes of K under random locations
K_cluster_env <- envelope(p_cluster, Kest, correction = "border")
# Repeat for regular data
K_regular_env <- envelope(p_regular, Kest, correction = "border")
# Insert the full formula to plot K minus pi * r^2
plot(K_cluster_env, . - pi * r ^ 2 ~ r)
plot(K_regular_env, . - pi * r ^ 2 ~ r)
# Insert the full formula to plot K minus pi * r^2
plot(K_cluster_env, . - pi * r ^ 2 ~ r)
# Subtract pi * r ^ 2 from the Y-axis and plot
plot(K_poisson, . - pi * r ^ 2 ~ r) #essentially centers the red line (the line of a ideal poisson distribution), and therefore also shows the deviance from our distribution (just as the previous plot)
# The default plot shows quadratic growth
plot(K_poisson, . ~ r)
redoak <- readRDS("data/redoak.rds")
plot(redoak)
quadrat.test(p1, alternative = "clustered") # Clustered
quadrat.test(redoak, alternative = "clustered") # Clustered
library(raster)
library(rgdal)
preston_crime <- readRDS("data/pcrime-spatstat.rds")
preston_osm <- readRDS("data/osm_preston_gray.rds")
preston_crime <- readRDS("data/pcrime-spatstat.rds")
preston_osm <- readRDS("data/osm_preston_gray.rds")
library(raster)
library(rgdal)
preston_crime <- readRDS("data/pcrime-spatstat.rds")
preston_osm <- readRDS("data/osm_preston_gray.rds")
p_load(spatstat)
# Load the spatstat package
library(pacman)
p_load(spatstat)
# Get some summary information on the dataset
summary(preston_crime)
# Get a table of marks
table(marks(preston_crime))
# Define a function to create a map
preston_map <- function(cols = c("green","red"), cex = c(1, 1), pch = c(1, 1)) {
plotRGB(preston_osm) # loaded above
plot(preston_crime, cols = cols, pch = pch, cex = cex, add = TRUE, show.window = TRUE)
}
# Get some summary information on the dataset
summary(preston_crime)
# Draw the map with colors, sizes and plot character
preston_map(
#  cols = c("___", "___"),
cex = c(0.5, 1),
#  pch = ___
)
# Define a function to create a map
preston_map <- function(cols = c("black","red"), cex = c(1, 1), pch = c(1, 1)) {
plotRGB(preston_osm) # loaded above
plot(preston_crime, cols = cols, pch = pch, cex = cex, add = TRUE, show.window = TRUE)
}
# Draw the map with colors, sizes and plot character
preston_map(
#  cols = c("___", "___"),
cex = c(0.5, 1),
#  pch = ___
)
# Draw the map with colors, sizes and plot character
preston_map(
#  cols = c("___", "___"),
cex = c(0.5, 4),
#  pch = ___
)
# Draw the map with colors, sizes and plot character
preston_map(
#  cols = c("___", "___"),
cex = c(0.5, 2),
#  pch = ___
)
# Draw the map with colors, sizes and plot character
preston_map(
#  cols = c("___", "___"),
cex = c(0.1, 2),
#  pch = ___
)
# Draw the map with colors, sizes and plot character
preston_map(
#  cols = c("___", "___"),
cex = c(0.1, 1),
#  pch = ___
)
# preston_crime has been pre-defined
preston_crime
# Use the split function to show the two point patterns
crime_splits <- split(preston_crime)
# Plot the split crime
plot(crime_splits)
# Compute the densities of both sets of points
crime_densities <- density(crime_splits)
# Calc the violent density divided by the sum of both
frac_violent_crime_density <- crime_densities[[2]] /
(crime_densities[[1]] + crime_densities[[2]])
# Plot the density of the fraction of violent crime
plot(frac_violent_crime_density)
# Use the split function to show the two point patterns
crime_splits <- split(preston_crime)
# Plot the split crime
plot(crime_splits)
# Plot the density of the fraction of violent crime
plot(frac_violent_crime_density)
# Inspect the structure of the spatial segregation object
str(seg)
# Install spatialkernel (the CRAN version is outdated, so you need to grab the most recent maintained version from Github). You may need to install.packages("devtools") and then run:
devtools::install_github("becarioprecario/spatialkernel")
# Libraries
library(spatstat)
library(spatialkernel)
# Install spatialkernel (the CRAN version is outdated, so you need to grab the most recent maintained version from Github). You may need to install.packages("devtools") and then run:
library(devtools)
devtools::install_github("becarioprecario/spatialkernel")
# Install spatialkernel (the CRAN version is outdated, so you need to grab the most recent maintained version from Github). You may need to install.packages("devtools") and then run:
install.packages(devtools)
# Install spatialkernel (the CRAN version is outdated, so you need to grab the most recent maintained version from Github). You may need to install.packages("devtools") and then run:
install.packages(devtools)
# Install spatialkernel (the CRAN version is outdated, so you need to grab the most recent maintained version from Github). You may need to install.packages("devtools") and then run:
install.packages("devtools")
devtools::install_github("becarioprecario/spatialkernel")
devtools::install_github("becarioprecario/spatialkernel")
library(pacman)
p_load(spatialkernel)
# Libraries
library(spatstat)
library(spatialkernel)
devtools::install_github("becarioprecario/spatialkernel")
p_load(withr, spatialkernel)
p_load(withr)
p_load(spatialkernel)
devtools::install_github("becarioprecario/spatialkernel")
pkgbuild::check_build_tools(debug = TRUE)
spatstat
p_load(spatialkernel)
writeLines('PATH="${RTOOLS40_HOME}\\usr\\bin;${PATH}"', con = "~/.Renviron")
devtools::install_github("becarioprecario/spatialkernel")
Sys.which(“make”)
Sys.which("make")
Sys.which("make")
writeLines('PATH="${RTOOLS40_HOME}\\usr\\bin;${PATH}"', con = "~/.Renviron")
writeLines('PATH="${RTOOLS40_HOME}\\usr\\bin;${PATH}"', con = "~/.Renviron")
Sys.which("make")
writeLines('PATH="${RTOOLS40_HOME}\\usr\\bin;${PATH}"', con = "~/.Renviron")
Sys.which("make")
# Install spatialkernel (the CRAN version is outdated, so you need to grab the most recent maintained version from Github). You may need to install.packages("devtools") and then run:
library(pacman)
p_load(devtools)
p_load(withr, spatstat)
writeLines('PATH="${RTOOLS40_HOME}\\usr\\bin;${PATH}"', con = "~/.Renviron")
Sys.which("make")
p_load(spatialkernel)
devtools::install_github("becarioprecario/spatialkernel")
pkgbuild::check_build_tools(debug = TRUE)
# Data
preston_crime <- read.dcf("data/pcrime-spatstat.rds")
# Data
preston_crime <- readRDS("data/pcrime-spatstat.rds")
# Scan from 500m to 1000m in steps of 50m
bw_choice <- spseg(
preston_crime,
#    h = seq(___, ___, by = ___),
opt = 1)
p_load(spatialkernel,spseg)
# Scan from 500m to 1000m in steps of 50m
bw_choice <- spseg(
preston_crime,
h = seq(500, 100, by = 50),
opt = 1)
p_load(spatialkernel)
# Scan from 500m to 1000m in steps of 50m
bw_choice <- spseg(
preston_crime,
h = seq(500, 100, by = 50),
opt = 1)
# Scan from 500m to 1000m in steps of 50m
bw_choice <- spseg(
preston_crime,
h = seq(500, 100, by = 50),
opt = 1)
?spseg
# Scan from 500m to 1000m in steps of 50m
bw_choice <- spseg(
preston_crime,
h = seq(500, 1000, by = 50),
opt = 1)
bw_choice
columns(bw_choice)
column(bw_choice)
column(bw_choice)
View(bw_choice)
library(pacman)
p_load(devtools)
p_load(withr, spatstat)
p_load(spatialkernel)
# Data
preston_crime <- readRDS("data/pcrime-spatstat.rds")
# Scan from 500m to 1000m in steps of 50m
bw_choice <- spseg(
preston_crime,
h = seq(500, 1000, by = 50),
opt = 1)
bw_choice
head(bw_choice)
bw_choice[1][1:10]
colnames(bw_choice)
View(bw_choice)
# Plot the results and highlight the best bandwidth
plotcv(bw_choice); abline(v = bw_choice$hcv, lty = 2, col = "red")
# Print the best bandwidth
print(bw_choice$hcv)
# Set the correct bandwidth and run for 10 simulations only
seg10 <- spseg(
pts = preston_crime,
h = bw_choice$hcv,
opt = 3,
ntest = 10,
proc = FALSE)
?plotmc
# Plot the segregation map for violent crime
plotmc(seg10, "___")
# Plot the segregation map for violent crime
plotmc(seg10, "Violent crime")
# You can modify the script above to run 1000 simulations if you have 20 mins of time. Alternatively, load the 'seg' object from data/.
seg <- readRDS("data/seg.rds")
# Plot seg, the result of running 1000 simulations
plotmc(seg, "Violent crime")
# Get the number of columns in the data so we can rearrange to a grid
ncol <- length(seg$)
# Inspect the structure of the spatial segregation object
str(seg)
# Get the number of columns in the data so we can rearrange to a grid
#ncol <- length(seg$___)
ncol <- length/colnames(seg)
# Get the number of columns in the data so we can rearrange to a grid
#ncol <- length(seg$___)
ncol <- length(colnames(seg))
ncol
# Get the number of columns in the data so we can rearrange to a grid
#ncol <- length(seg$___)
colnames(seg)
# Inspect the structure of the spatial segregation object
str(seg)
# Get the number of columns in the data so we can rearrange to a grid
ncol <- length(seg$gridx)
# Rearrange the probability column into a grid
prob_violent <- list(x = seg$gridx
y = seg$gridy,
z = matrix(seg$p[, "Violent crime"],
ncol = ncol))
# Rearrange the probability column into a grid
prob_violent <- list(x = seg$gridx,
y = seg$gridy,
z = matrix(seg$p[, "Violent crime"],
ncol = ncol))
# You have basically georeferenced the image within data's coordinates
image(prob_violent)
# Rearrange the p-values, but choose a p-value threshold
p_value <- list(x = seg$gridx,
y = seg$gridy,
z = matrix(seg$p[, "Violent crime"]< 0.05,
ncol = ncol))
image(p_value)
# Create a mapping function
segmap <- function(prob_list, pv_list, low, high){
# background map
library(raster)
preston_osm <- ______("data/osm_preston_gray.rds")
plotRGB(preston_osm)
# p-value areas
image(pv_list,
col = c("#00000000", "#FF808080"), add = TRUE)
# probability contours
contour(prob_list,
levels = c(low, high),
col = c("#206020", "red"),
labels = c("Low", "High"),
add = TRUE)
# boundary window
plot(Window(preston_crime), add = TRUE)
}
# Create a mapping function
segmap <- function(prob_list, pv_list, low, high){
# background map
library(raster)
preston_osm <- readRDS("data/osm_preston_gray.rds")
plotRGB(preston_osm)
# p-value areas
image(pv_list,
col = c("#00000000", "#FF808080"), add = TRUE)
# probability contours
contour(prob_list,
levels = c(low, high),
col = c("#206020", "red"),
labels = c("Low", "High"),
add = TRUE)
# boundary window
plot(Window(preston_crime), add = TRUE)
}
# Map the probability and p-value
segmap(prob_violent, p_value, 0, 5)
# Map the probability and p-value
segmap(prob_violent, p_value, 0, 80)
# Map the probability and p-value
segmap(prob_violent, p_value, 0.05, 0.10)
# Map the probability and p-value
segmap(prob_violent, p_value, 0.0, 0.05)
# Map the probability and p-value
segmap(prob_violent, p_value, 0.0, 0.2)
# Map the probability and p-value
segmap(prob_violent, p_value, 0.0, 0.05)
# Map the probability and p-value
segmap(prob_violent, p_value, 0.0, 0.10)
# Map the probability and p-value
segmap(prob_violent, p_value, 0.0, 0.16)
# Map the probability and p-value
segmap(prob_violent, p_value, 0.0, 0.20)
# Map the probability and p-value
segmap(prob_violent, p_value, 0.2, 0.4)
# Map the probability and p-value
segmap(prob_violent, p_value, 0.95, 0.05)
# Map the probability and p-value
segmap(prob_violent, p_value, 0.80, 0.05)
# Map the probability and p-value
segmap(prob_violent, p_value, 0.70, 0.05)
# Map the probability and p-value
segmap(prob_violent, p_value, 0.70, 0.10)
# Map the probability and p-value
segmap(prob_violent, p_value, 0.0, 0.10)
# Map the probability and p-value
segmap(prob_violent, p_value, 0.05, 0.10)
# Map the probability and p-value
segmap(prob_violent, p_value, 0.10, 0.90)
# Map the probability and p-value
segmap(prob_violent, p_value, 0.05, 0.90)
# Map the probability and p-value
segmap(prob_violent, p_value, 0.05, 0.15)
?contour
# Map the probability and p-value
segmap(prob_violent, p_value, 0.05, 0.15)
prob_list
prob_violent
# Map the probability and p-value
segmap(prob_violent, p_value, 0.05, 0.2)
# Map the probability and p-value
segmap(prob_violent, p_value, 0.05, 0.10)
# Map the probability and p-value
segmap(prob_violent, p_value, 0.05, 0.12)
# Map the probability and p-value
segmap(prob_violent, p_value, 0.05, 0.15)
# Get the number of columns in the data so we can rearrange to a grid
ncol <- length(seg$gridx)
# Rearrange the probability column into a grid
prob_violent <- list(x = seg$gridx,
y = seg$gridy,
z = matrix(seg$p[, "Violent crime"],
ncol = ncol))
# You have basically georeferenced the image within data's coordinates
image(prob_violent)
# Rearrange the p-values, but choose a p-value threshold
p_value <- list(x = seg$gridx,
y = seg$gridy,
z = matrix(seg$p[, "Violent crime"]< 0.05,
ncol = ncol))
image(p_value)
# Rearrange the p-values, but choose a p-value threshold
p_value <- list(x = seg$gridx,
y = seg$gridy,
z = matrix(seg$p[, "Violent crime"]< 0.05,
ncol = ncol))
# Here it becomes evident that the areas
```
# Map the probability and p-value
segmap(prob_violent, p_value, 0.05, 0.15)
